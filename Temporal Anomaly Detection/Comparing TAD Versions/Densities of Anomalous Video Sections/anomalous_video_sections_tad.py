'''
Comparing TAD Simple Average to TAD Weighted Average. Comparing the densities of anomalous sections of the videos
generated by both TAD versions.
'''

import os
import sys
import argparse
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.ticker as mtick
from tqdm import tqdm
from numpy import load
import matplotlib.pylab as pl
import matplotlib.gridspec as gridspec


def parse_command_line_interface():
    '''
        Parses the command line arguments.
        Returns
        -------
        parsed_args: dict
            Key value pairs of arguments.
        '''
    parser = argparse.ArgumentParser(description = "This script calculates the densities of anomalous sections of the videos generated by both TAD versions.")
    parser.add_argument("-i","--eigen_directory", type = str, required = True, help = "This is the path to the file directory with the NumPy arrays")
    args = vars(parser.parse_args())
    return(args)

parsed_args = parse_command_line_interface() #parsed_args consists of the key value pairs of the argument

path_to_directory = parsed_args["eigen_directory"] #Key to your directory

your_directory = os.listdir(path_to_directory) #Your actual working directory

print(your_directory) #To make sure that you are in the correct directory where the npz files are


llo_list = []
mdivi_list = []
control_list = []

for item in your_directory:
    if ".npz" and "LLO" in item:
        data = np.load(item)
        eigen_vals = data["eigen_vals"]
        llo_list.append(eigen_vals)
    elif ".npz" and "Mdivi" in item:
        data = np.load(item)
        eigen_vals = data["eigen_vals"]
        mdivi_list.append(eigen_vals)
    elif ".npz" in item:
        data = np.load(item)
        eigen_vals = data["eigen_vals"]
        control_list.append(eigen_vals)

eigenvals_list = [llo_list,mdivi_list,control_list]



def frequencies_of_anomalous_video_sections(eigenvals_list, tad_version, window, threshold,bins, density):
    '''
        Generates a figure comprised of three histogram sub-plots.
        Each sub-plot corresponds to data from one of the three mitochondrial
        conditions (Control, LLO, MDIVI) in which the imaged cells were coerced and,
        by implementing one of the two TAD versions and different window and
        threshold parameter values, plots the density of anomalous sections from
        all videos within that mitochondrial condition.
        Parameters
        ----------
        eigenvals_list: list
            A list containing three sub-lists.
            Each sub-list contains the eigenval
            NumPy arrays from the experiemental
            group (mitochondrial condition).
        tad_version: string
            The inputs are "Weighted Average" and
            "Simple Average." Determines which
            version of the temporal anomaly detection
            is ran.
        window: int
            The size of the window to be used for anomaly
            detection.
        threshold: float
            Value used to determine whether a signal value
            is anomalous.
        bins: int
            How many bins to display in the histogram.
        density: boolean
            If True, draw and return a probability density:
            each bin will display the bin's raw count divided
            by the total number of counts and the bin width
            (density = counts / (sum(counts) * np.diff(bins))),
            so that the area under the histogram integrates to
            1 (np.sum(density * np.diff(bins)) == 1).
        Returns
        -------
        NoneType object
        '''
    signals_list = []
    if tad_version == "Simple Average":
        for i in range(len(eigenvals_list)):
            sub_list = eigenvals_list[i]
            for j in range(len(sub_list)):
                eigen_vals = sub_list[j]
                eigen_vals_avgs = [np.mean(x) for x in eigen_vals]
                moving_avgs = np.empty(shape=(eigen_vals.shape[0],), dtype=float) * 0
                moving_stds = np.empty(shape=(eigen_vals.shape[0],), dtype=float) * 0
                z_scores = np.empty(shape=(eigen_vals.shape[0],), dtype=float) * 0
                signals = np.empty(shape=(eigen_vals.shape[0],), dtype=float) * 0
                for i in range(window, moving_avgs.shape[0]):
                    moving_avgs[i] = np.mean(eigen_vals_avgs[i - window:i])
                    moving_stds[i] = np.std(eigen_vals_avgs[i - window:i])
                    z_scores[i] = (eigen_vals_avgs[i] - moving_avgs[i]) / moving_stds[i]
                    for i, score in enumerate(z_scores):
                        if score > threshold:
                            signals[i] = 1
                        elif score < threshold * -1:
                            signals[i] = -1
                        else:
                            signals[i] = 0
                signals_list.append(signals)


    elif tad_version == "Weighted Average":
        for i in range(len(eigenvals_list)):
            sub_list = eigenvals_list[i]
            for j in range(len(sub_list)):
                eigen_vals = sub_list[j]
                number_of_rows = eigen_vals.shape[0]
                number_of_columns = eigen_vals.shape[1]
                weights_array = np.empty(shape=(number_of_rows, number_of_columns)) * 0
                eigen_vals_weighted_avgs = np.empty(shape=(number_of_rows))
                for row in range(number_of_rows):
                    for column in range(number_of_columns):
                        array_entry = eigen_vals[row, column]
                        sum_of_row = np.sum(eigen_vals[row,])
                        weights_array[row, column] = array_entry * (array_entry / sum_of_row)
                        eigen_vals_weighted_avgs[row] = np.sum(weights_array[row,])
                moving_avgs = np.empty(shape=(eigen_vals.shape[0],), dtype=float) * 0
                moving_stds = np.empty(shape=(eigen_vals.shape[0],), dtype=float) * 0
                z_scores = np.empty(shape=(eigen_vals.shape[0],), dtype=float) * 0
                signals = np.empty(shape=(eigen_vals.shape[0],), dtype=float) * 0
                for i in range(window, moving_avgs.shape[0]):
                    moving_avgs[i] = np.mean(eigen_vals_weighted_avgs[i - window:i])
                    moving_stds[i] = np.std(eigen_vals_weighted_avgs[i - window:i])
                    z_scores[i] = (eigen_vals_weighted_avgs[i] - moving_avgs[i]) / moving_stds[i]
                    for i, score in enumerate(z_scores):
                        if score > threshold:
                            signals[i] = 1
                        elif score < threshold * -1:
                            signals[i] = -1
                        else:
                            signals[i] = 0
                signals_list.append((signals))


    anomalous_sections_of_video_llo = []
    for l in range(len(llo_list)):
        for count, value in enumerate(signals_list[l]):
            if (value == 1):
                anomalous_sections_of_video_llo.append(count / len(signals_list[l]))
            elif (value == -1):
                anomalous_sections_of_video_llo.append(count / len(signals_list[l]))

    anomalous_sections_of_video_mdivi = []
    for m in range(len(llo_list), len(llo_list) + len(mdivi_list)):
        for count, value in enumerate(signals_list[m]):
            if (value == 1):
                anomalous_sections_of_video_mdivi.append(count / len(signals_list[m]))
            elif (value == -1):
                anomalous_sections_of_video_mdivi.append(count / len(signals_list[m]))

    anomalous_sections_of_video_control = []
    for c in range(len(llo_list) + len(mdivi_list), len(llo_list) + len(mdivi_list) + len(control_list)):
        for count, value in enumerate(signals_list[c]):
            if (value == 1):
                anomalous_sections_of_video_control.append(count / len(signals_list[c]))
            elif (value == -1):
                anomalous_sections_of_video_control.append(count / len(signals_list[c]))

    gs = gridspec.GridSpec(2, 2)
    fig = pl.figure()
    fig.suptitle("Density of Anomalous Video Sections " + str(tad_version) + " \nWindow = " + str(window) +  " Threshold = " + str(threshold))
    ax = pl.subplot(gs[0, 0])
    pl.hist(anomalous_sections_of_video_llo, color="indianred", label="LLO", edgecolor='black', linewidth=1.2, bins= bins, density = density)
    ax.set_ylabel("Density")
    ax.legend()

    ax = pl.subplot(gs[0, 1])
    ax.hist(anomalous_sections_of_video_mdivi, color="lightseagreen", label="MDIVI", edgecolor='black', linewidth=1.2,bins= bins, density = density)
    ax.set_ylabel("Density")
    ax.legend()

    ax = pl.subplot(gs[1, :])
    ax.hist(anomalous_sections_of_video_control, color="goldenrod", label="Control", edgecolor='black', linewidth=1.2,bins= bins,density = density)
    ax.set_ylabel("Density")
    ax.set_xlabel("Section (Frame/Number of Frames In Video) of the Video Declared Anomalous")
    ax.legend()

    figure = plt.gcf()
    figure.set_size_inches(8, 6)
    #plt.savefig(fname="DensitiesHist" + str(tad_version) + "W" + str(window) + "T" + str(threshold) + ".jpg", dpi=100)
    plt.show()

for window in [10,20,50]:
    for threshold in [2.0,2.5,3.0]:
        frequencies_of_anomalous_video_sections(eigenvals_list= eigenvals_list, tad_version= "Simple Average",
                                                window = window, threshold= threshold, bins = 8, density = True)
        frequencies_of_anomalous_video_sections(eigenvals_list=eigenvals_list, tad_version="Weighted Average", window= window,
                                            threshold=threshold, bins= 8, density= True)






